---
title: 代码随想录刷题笔记（二叉树）
date: 2025-05-09 16:46:53
tags: [刷题, 二叉树]
categories: 代码随想录
description: 主要是代码随想录二叉树一节中我觉得自己还掌握不太好的点、一些很wise的点或者一些其他的感想
---

# 二叉树的遍历方式

 二叉树有四种常考的遍历方式，其中前中后序的思路比较相近，其中的**前、中、后表示的意思是中间节点（父节点）的访问顺序是在左右子树的访问前，还是在左右子树访问的中间，还是在左右子树的访问后**。

这里的访问顺序的含义一般是获取值，或者对这个值进行某些操作。

如果采用迭代的方法，前中后序的数据结构使用的是栈，而层序使用的是队列。

遍历方式上也有所不同，前中后采用的是深度优先遍历的方式，而层序采用的是广度优先的遍历方式

## 前序遍历

前序遍历的意思就是先访问中间节点，再访问左子树，再访问右子树，即中左右的顺序。

以下是前序遍历的实现：

```C++
void traversal(TreeNode* cur, vector<int>& vec)
{
    if(cur == nullptr)	return;
    vec.push_back(cur->val);
    traversal(cur->left, vec);
    traversal(cur->right, vec);
}
```

## 中序遍历

中序遍历的意思是先访问左子树，再访问中间节点，再访问右子树，即左中右的顺序。

以下是中序遍历的实现：

```C++
void traversal(TreeNode* cur, vector<int>& vec)
{
    if(cur == nullptr)	return;
    traversal(cur->left, vec);
    vec.push_back(cur->val);
    traversal(cur->right, vec);
}
```

## 后序遍历

后序遍历的意思是先访问左子树，再访问右子树，再访问中间节点，即左右中的顺序。

以下是中序遍历的实现方式：

```C++
void traversal(TreeNode* cur, vector<int>& vec)
{
    if(cur == nullptr)	return;
    traversal(cur->left, vec);
    traversal(cur->right, vec);
    vec.push_back(cur->val);
}
```

## 栈实现前中后序

正如前面所说，前中后序可以通过栈来实现。

这里我学的方法是使用一个`nullptr`来标识这个中间节点是否到了该访问的时候，同样的也可以用`pair<TreeNode*, bool>`来记录。

如果访问到了一个nullptr，说明这个nullptr下面的节点是一个中间节点，现在到了该访问它的时候了。

如果不是一个nullptr，就按所需顺序（前中后）来访问它和它的子节点。

这里需要注意的是，栈是一个先进后出的数据结构，所以我们需要倒过来访问。

### 前序遍历：

遍历顺序是中左右，说明入栈顺序是右左中

```C++
vector<int> preOrder(TreeNode* root)
{
    vector<int> result;
    stack<TreeNode*> stk
    if(root != nullptr)
        stk.push(root);
    while(!stk.empty())
    {
        TreeNode* node = stk.top();
        if(node != nullptr) 
        {
            stk.pop();
            if(node->right)	stk.push(node->right);
            if(node->left)	stk.push(node->left);
            stk.push(node);
            stk.push(nullptr);
        }
        else // 是nullptr的情况，说明nullptr下面的是一个中间节点，且到了访问这个中间节点的时候了
        {
            stk.pop(); //去掉nullptr
            result.push_back(stk.top()->val);
            stk.pop();
        }
    }
    return result;
}
```

### 中序遍历：

遍历顺序是左中右，说明入栈顺序是右中左

```C++
vector<int> inOrder(TreeNode* root)
{
    vector<int> result;
    stack<TreeNode*> stk
    if(root != nullptr)
        stk.push(root);
    while(!stk.empty())
    {
        TreeNode* node = stk.top();
        if(node != nullptr) 
        {
            stk.pop();
            if(node->right)	stk.push(node->right);
            stk.push(node);
            stk.push(nullptr);
            if(node->left)	stk.push(node->left); 
        }
        else // 是nullptr的情况，说明nullptr下面的是一个中间节点，且到了访问这个中间节点的时候了
        {
            stk.pop(); //去掉nullptr
            result.push_back(stk.top()->val);
            stk.pop();
        }
    }
    return result;
}
```

### 后续遍历:

遍历顺序是左右中，说明入栈顺序是中右左

```C++
vector<int> postOrder(TreeNode* root)
{
    vector<int> result;
    stack<TreeNode*> stk
    if(root != nullptr)
        stk.push(root);
    while(!stk.empty())
    {
        TreeNode* node = stk.top();
        if(node != nullptr) 
        {
            stk.pop();
            stk.push(node);
            stk.push(nullptr);
            if(node->right)	stk.push(node->right);
            if(node->left)	stk.push(node->left); 
        }
        else // 是nullptr的情况，说明nullptr下面的是一个中间节点，且到了访问这个中间节点的时候了
        {
            stk.pop(); //去掉nullptr
            result.push_back(stk.top()->val);
            stk.pop();
        }
    }
    return result;
}
```

## 层序遍历

层序遍历就是一层一层地访问二叉树。

具体的思路就是将每一层的所有元素都放进队列里，然后再依次出队，将这些元素的左儿子和右儿子放入队列，并将自己的值记录下来。

```c++
vector<vector<int>> levelOrder(TreeNode* root)
{
    queue<TreeNode*> q;
    if(root != nullptr)
        q.push(root);
   	vector<vector<int>> result;
    while(!q.empty())
    {
        int n = q.size();
        vector<int> vec;
        for(int i=0; i<n; i++)
        {
            TreeNode* node = q.front();
            q.pop();
            vec.push(node->val);
            if(node->left) q.push(node->left);
            if(node->right) q.push(node->right);
        }
        result.push_back(vec);
    }
    return result;
}
```





# 完全二叉树的节点个数

## 完全二叉树

### 定义

在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（从第 0 层开始），则该层包含 1~ $2^h$个节点。

### 特性

对于一棵完全二叉树，有两种可能：

1. 满二叉树
2. 非满二叉树

这不是废话吗？诶，先别急。满二叉树很重要。

那我们如何判断一颗满二叉树呢？

#### 满二叉树的判断方法

从根节点开始，向左遍历和向右遍历。

![满二叉树](https://file.kamacoder.com/pics/20220829163554.png)

如果深度相同，则这棵完全二叉树是满二叉树。

而满二叉树的节点计算公式很简单：$2^n-1$，n为层数或者深度

这又有什么用呢？可以加速完全二叉树节点的计算。

#### 加速求完全二叉树节点数

首先，通过判断是否为满二叉树，我们可以将求满二叉树的节点数的时间复杂度从`O(n)`加速到`O(logn)`，因为我们只需要两次$logn$复杂度的计算.。

OK，接下来就是完全二叉树和满二叉树之间的联系了。除了满二叉树是一种特殊的二叉树这一点之外，他们还有一个很重要的联系是：**对完全二叉树分别递归左孩子，和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树**

这有什么用呢，我们可以对这些遍历到的节点先进行一次判断，以这个节点为根的子二叉树是不是满二叉树，如果是，则可以用满二叉树节点数计算公式快速求解，如果不是，则继续递归左右节点。

![222.完全二叉树的节点个数](https://file.kamacoder.com/pics/20201124092543662.png)

就像这个一样，这几颗满二叉树都能快速求解。相较于遍历每个节点的时间复杂度$O(n)$，这种做法的时间复杂度只有$O(logn × logn)$

# 从中序和后序（前序）构造二叉树

当我们知道一个二叉树的中序，且知道前序后序中的任意一个，我们就可以确定二叉树。

这道题，还是有不好的回忆的，因为我网易雷火的二面上就遇到了这道题，但是当时我没做出来。

这题主要是分治的思想。

![106.从中序与后序遍历序列构造二叉树](https://file.kamacoder.com/pics/20210203154249860.png)

前序数组的第一个数和后序数组的最后一个数，就是这棵树的根节点。

这个数会将中序数组分成两部分，中序数组中这个位置左边的数构成左子树，右边的数构成右子树。

既然是子树，那么就可以采用相同的一个处理思路，直到空节点。

所以就
