---
title: 代码随想录刷题笔记（二叉树）
date: 2025-05-09 16:46:53
tags: [刷题, 二叉树, 递归]
categories: 代码随想录
description: 主要是代码随想录二叉树一节中我觉得自己还掌握不太好的点、一些很wise的点或者一些其他的感想
---

# 二叉树的遍历方式

 二叉树有四种常考的遍历方式，其中前中后序的思路比较相近，其中的**前、中、后表示的意思是中间节点（父节点）的访问顺序是在左右子树的访问前，还是在左右子树访问的中间，还是在左右子树的访问后**。

这里的访问顺序的含义一般是获取值，或者对这个值进行某些操作。

如果采用迭代的方法，前中后序的数据结构使用的是栈，而层序使用的是队列。

遍历方式上也有所不同，前中后采用的是深度优先遍历的方式，而层序采用的是广度优先的遍历方式

## 前序遍历

前序遍历的意思就是先访问中间节点，再访问左子树，再访问右子树，即中左右的顺序。

以下是前序遍历的实现：

```C++
void traversal(TreeNode* cur, vector<int>& vec)
{
    if(cur == nullptr)	return;
    vec.push_back(cur->val);
    traversal(cur->left, vec);
    traversal(cur->right, vec);
}
```

## 中序遍历

中序遍历的意思是先访问左子树，再访问中间节点，再访问右子树，即左中右的顺序。

以下是中序遍历的实现：

```C++
void traversal(TreeNode* cur, vector<int>& vec)
{
    if(cur == nullptr)	return;
    traversal(cur->left, vec);
    vec.push_back(cur->val);
    traversal(cur->right, vec);
}
```

## 后序遍历

后序遍历的意思是先访问左子树，再访问右子树，再访问中间节点，即左右中的顺序。

以下是中序遍历的实现方式：

```C++
void traversal(TreeNode* cur, vector<int>& vec)
{
    if(cur == nullptr)	return;
    traversal(cur->left, vec);
    traversal(cur->right, vec);
    vec.push_back(cur->val);
}
```

## 栈实现前中后序

正如前面所说，前中后序可以通过栈来实现。

这里我学的方法是使用一个`nullptr`来标识这个中间节点是否到了该访问的时候，同样的也可以用`pair<TreeNode*, bool>`来记录。

如果访问到了一个nullptr，说明这个nullptr下面的节点是一个中间节点，现在到了该访问它的时候了。

如果不是一个nullptr，就按所需顺序（前中后）来访问它和它的子节点。

这里需要注意的是，栈是一个先进后出的数据结构，所以我们需要倒过来访问。

### 前序遍历：

遍历顺序是中左右，说明入栈顺序是右左中

```C++
vector<int> preOrder(TreeNode* root)
{
    vector<int> result;
    stack<TreeNode*> stk
    if(root != nullptr)
        stk.push(root);
    while(!stk.empty())
    {
        TreeNode* node = stk.top();
        if(node != nullptr) 
        {
            stk.pop();
            if(node->right)	stk.push(node->right);
            if(node->left)	stk.push(node->left);
            stk.push(node);
            stk.push(nullptr);
        }
        else // 是nullptr的情况，说明nullptr下面的是一个中间节点，且到了访问这个中间节点的时候了
        {
            stk.pop(); //去掉nullptr
            result.push_back(stk.top()->val);
            stk.pop();
        }
    }
    return result;
}
```

### 中序遍历：

遍历顺序是左中右，说明入栈顺序是右中左

```C++
vector<int> inOrder(TreeNode* root)
{
    vector<int> result;
    stack<TreeNode*> stk
    if(root != nullptr)
        stk.push(root);
    while(!stk.empty())
    {
        TreeNode* node = stk.top();
        if(node != nullptr) 
        {
            stk.pop();
            if(node->right)	stk.push(node->right);
            stk.push(node);
            stk.push(nullptr);
            if(node->left)	stk.push(node->left); 
        }
        else // 是nullptr的情况，说明nullptr下面的是一个中间节点，且到了访问这个中间节点的时候了
        {
            stk.pop(); //去掉nullptr
            result.push_back(stk.top()->val);
            stk.pop();
        }
    }
    return result;
}
```

### 后续遍历:

遍历顺序是左右中，说明入栈顺序是中右左

```C++
vector<int> postOrder(TreeNode* root)
{
    vector<int> result;
    stack<TreeNode*> stk
    if(root != nullptr)
        stk.push(root);
    while(!stk.empty())
    {
        TreeNode* node = stk.top();
        if(node != nullptr) 
        {
            stk.pop();
            stk.push(node);
            stk.push(nullptr);
            if(node->right)	stk.push(node->right);
            if(node->left)	stk.push(node->left); 
        }
        else // 是nullptr的情况，说明nullptr下面的是一个中间节点，且到了访问这个中间节点的时候了
        {
            stk.pop(); //去掉nullptr
            result.push_back(stk.top()->val);
            stk.pop();
        }
    }
    return result;
}
```

## 层序遍历

层序遍历就是一层一层地访问二叉树。

具体的思路就是将每一层的所有元素都放进队列里，然后再依次出队，将这些元素的左儿子和右儿子放入队列，并将自己的值记录下来。

```c++
vector<vector<int>> levelOrder(TreeNode* root)
{
    queue<TreeNode*> q;
    if(root != nullptr)
        q.push(root);
   	vector<vector<int>> result;
    while(!q.empty())
    {
        int n = q.size();
        vector<int> vec;
        for(int i=0; i<n; i++)
        {
            TreeNode* node = q.front();
            q.pop();
            vec.push(node->val);
            if(node->left) q.push(node->left);
            if(node->right) q.push(node->right);
        }
        result.push_back(vec);
    }
    return result;
}
```





# 完全二叉树的节点个数

## 完全二叉树

### 定义

在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（从第 0 层开始），则该层包含 1~ $2^h$个节点。

### 特性

对于一棵完全二叉树，有两种可能：

1. 满二叉树
2. 非满二叉树

这不是废话吗？诶，先别急。满二叉树很重要。

那我们如何判断一颗满二叉树呢？

#### 满二叉树的判断方法

从根节点开始，向左遍历和向右遍历。

![满二叉树](https://file.kamacoder.com/pics/20220829163554.png)

如果深度相同，则这棵完全二叉树是满二叉树。

而满二叉树的节点计算公式很简单：$2^n-1$，n为层数或者深度

这又有什么用呢？可以加速完全二叉树节点的计算。

#### 加速求完全二叉树节点数

首先，通过判断是否为满二叉树，我们可以将求满二叉树的节点数的时间复杂度从`O(n)`加速到`O(logn)`，因为我们只需要两次$logn$复杂度的计算.。

OK，接下来就是完全二叉树和满二叉树之间的联系了。除了满二叉树是一种特殊的二叉树这一点之外，他们还有一个很重要的联系是：**对完全二叉树分别递归左孩子，和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树**

这有什么用呢，我们可以对这些遍历到的节点先进行一次判断，以这个节点为根的子二叉树是不是满二叉树，如果是，则可以用满二叉树节点数计算公式快速求解，如果不是，则继续递归左右节点。

![222.完全二叉树的节点个数](https://file.kamacoder.com/pics/20201124092543662.png)

就像这个一样，这几颗满二叉树都能快速求解。相较于遍历每个节点的时间复杂度$O(n)$，这种做法的时间复杂度只有$O(logn × logn)$

# 从中序和后序（前序）构造二叉树

当我们知道一个二叉树的中序，且知道前序后序中的任意一个，我们就可以确定二叉树。

这道题，还是有不好的回忆的，因为我网易雷火的二面上就遇到了这道题，但是当时我没做出来。

这题主要是分治的思想。

![106.从中序与后序遍历序列构造二叉树](https://file.kamacoder.com/pics/20210203154249860.png)

前序数组的第一个数和后序数组的最后一个数，就是这棵树的根节点。

这个数会将中序数组分成两部分，中序数组中这个位置左边的数构成左子树，右边的数构成右子树。

既然是子树，那么就可以采用相同的一个处理思路，直到空节点。

所以就直接使用递归调用就行了。

当然还是要注意一个很重要的东西，区间。一般像这种问题，涉及到一个同样问题，但是不同范围的。一定要注重区间，要从一开始做题的时候就确定下来到底是左开右开，左闭右开，左开右闭，还是左闭右闭。

## 后序+中序

```C++
//使用左闭右开区间，
void buildTree(vector<int>& inorder, int inBegin, int inEnd, vector<int>& postorder, int postBegin, int postEnd)
{	
    //递归结束条件，这里的话因为我们使用的是左闭右开，所以说只要inBegin == inEnd(postBegin == postEnd)，就说明这颗子树没有节点了，直接返回nullptr
    if(inBegin == inEnd)
        return nullptr;
    //找到后序最后一个数在中序的位置
    int delimeterIndex = inBegin;
    int rootValue = postorder[postEnd-1];
    TreeNode* root = new TreeNode(rootValue);
    for(delimeterIndex; delimeterIndex<inEnd; delimeterIndex++)
    {
        if(inorder[delimeterIndex] == rootValue)
            break;
    }
    //这个时候，我们可以知道，在中序中，[inBegin, delimeterIndex)中的是属于左子树，[delimeterIndex+1,inEnd)属于右子树
    //在后序中从[postBegin,postBegin + 中序左子树数组长度)中的数是左子树， [postBegin + 中序左子树数组长度, postEnd-1)属于右子树。
    //所以我们就能知道左子树和右子树的根节点应该是什么
    root->left = buildTree(inorder, inBegin, delimeterIndex, postorder, postBegin, postBegin+delimeterIndex-inBegin);
    root->right = buildTree(inorder, delimeterIndex+1, inEnd, postorder, postBegin+delimeterIndex-inBegin, postEnd-1);
    return root;
}
```

然后就能轻松通过啦。

## 前序+中序

其实也差不多，rootValue应该是preorder[preBegin]

```C++
//使用左闭右开区间，
void buildTree(vector<int>& inorder, int inBegin, int inEnd, vector<int>& preorder, int preBegin, int preEnd)
{	
   //递归结束条件，这里的话因为我们使用的是左闭右开，所以说只要inBegin == inEnd(preBegin == preEnd)，就说明这颗子树没有节点了，直接返回nullptr
    if(inBegin == inEnd)
        return nullptr;
    //找到后序最后一个数在中序的位置
    int delimeterIndex = inBegin;
    int rootValue = preorder[preBegin];
    TreeNode* root = new TreeNode(rootValue);
    for(delimeterIndex; delimeterIndex<inEnd; delimeterIndex++)
    {
        if(inorder[delimeterIndex] == rootValue)
            break;
    }
    //这个时候，我们可以知道，在中序中，[inBegin, delimeterIndex)中的是属于左子树，[delimeterIndex+1,inEnd)属于右子树
    //在后序中从[preBegin+1,preBegin + 中序左子树数组长度 + 1)中的数是左子树， [preBegin + 中序左子树数组长度 + 1, preEnd)属于右子树。
    //所以我们就能知道左子树和右子树的根节点应该是什么
    root->left = buildTree(inorder, inBegin, delimeterIndex, preorder, preBegin+1, preBegin+delimeterIndex-inBegin + 1);
    root->right = buildTree(inorder, delimeterIndex+1, inEnd, preorder, preBegin+delimeterIndex-inBegin+1, preEnd);
    return root;
}
```

# 搜索二叉树

## 性质

- 节点的左子树只包含小于当前节点的数。
- 节点的右子树只包含大于当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。
- 其中序遍历应该是一个有序数组

## 如何验证一棵搜索二叉树是否正确

这里需要注意的是，如果只比较中间节点和左右子节点是无法做到的。

![二叉搜索树](https://file.kamacoder.com/pics/20230310000824.png)

就像这个树一样。

翻译一下二叉搜索树的这两条性质：

- 节点的左子树只包含小于当前节点的数。
- 节点的右子树只包含大于当前节点的数。

根据这个树，根节点10左子树的范围应该是(-∞, 10)，右子树的应该是(10, +∞)。

进一步来看，二叉搜索树实际上是通过左子树和右子树来不断缩小范围的。左子树就是缩小最大值，右子树就是缩小最小值。

就比如最开始的范围应该是(-∞, +∞)，10的左子树就缩小了最大值范围，同样的，如果到5后，看右子树，就是缩小的最小值范围。

那么如果有一个节点的值，不满足这个范围，就说明这棵二叉搜索树是不正确的。

所以就有了一种做法：

### 思路1

```C++
bool isValidBST(TreeNode* root)
{
	return dfs(root);
}

bool dfs(TreeNode* root, long long left = LLONG_MIN, long long right = LLONG_MAX)//这里采用longlong是因为leetcode存在一个判例有int最小值
{
    if(root == nullptr)
        return true; //空树也是一个二叉搜索树
    long long x = root->val;
    return left < x && x < right //判断root是否符合当前范围
        && dfs(root->left, left, x) //判断左子树是否在[left, x]这个范围
        && dfs(root->right, x, right); //判断右子树是否在[x, right]这个范围
}
```

### 思路2

前面不是说了，搜索二叉树的中序遍历是一个有序数组吗？那很简单咯，直接中序遍历一遍，然后判断这个数组是否有序：

```C++
vector<int> vec;
void traversal(TreeNode* root) {
    if (root == NULL) return;
    traversal(root->left);
    vec.push_back(root->val); // 将二叉搜索树转换为有序数组
    traversal(root->right);
}

 bool isValidBST(TreeNode* root) {
    vec.clear(); // 不加这句在leetcode上也可以过，但最好加上
    traversal(root);
    for (int i = 1; i < vec.size(); i++) {
        // 注意要小于等于，搜索树里不能有相同元素
        if (vec[i] <= vec[i - 1]) return false;
    }
    return true;
}
```

这个方法确实很好，但我们基本需要对这棵树上的节点值进行两次查看（一次是树遍历的时候，一次是对值数组遍历的时候）。有没有办法直接在树遍历就把是否有序判断了？

有的兄弟，有的。

我们想一想，我们中序遍历构造这个数组的顺序是和后面判断数组是否有序而进行遍历的顺序是一模一样的。那么我们就可以在中序遍历的时候直接把这事干了。

```C++
long long maxVal = LONG_MIN;
bool isValidBST(TreeNode* root)
{
    if(root = nullptr)	return true;
    
    bool left = isValidBST(root->left);
    // 中序遍历，验证遍历的元素是不是从小到大
    if (maxVal < root->val) maxVal = root->val;
    else return false;
    bool right = isValidBST(root->right);

    return left && right;
}
```

这里使用了一个maxVal来记录上一个中序遍历到的节点，因为只需要看前一个就行了。

如果中序遍历发现比前一个小，说明不满足中序遍历递增，也就是错误的搜索二叉树。

## 二叉搜索树 = 有序链表（有序数组）？

由于二叉搜索树的中序遍历是一个**有序的数组**，所以很多有关二叉搜索树的题，我们都可以用**数组**的思路来做。

就比如LEETCODE530：二叉搜索树的最小绝对差。我们就可以转化成有序数组中最小绝对差。

再用数轴来理解，既然有序，那么两数绝对差就是数轴上两数的距离，那么有最小绝对差的两数，一定是相邻的。

那回到中序遍历上来，我就只需要中序遍历一次二叉树，不断计算当前中序遍历到的节点和上一个遍历到的节点的差值，然后记录最小值就行了。

然后递归中如果需要记录前一个访问节点，只需要设置一个全局的变量pre，然后在进行下一个的时候进行修改就行了。

代码大致如下：

```C++
int result = INT_MAX;
TreeNode* pre = nullptr;
void traversal(TreeNode* cur)
{
	if(cur == nullptr)
        return;
    traversal(cur->left);
    if(pre != nullptr)
        result = min(cur->val - pre->val, result);
    pre = cur;
    traversal(cur->right);
}

int getMinimumDifference(TreeNode* root) {
    traversal(root);
    return result;
}
```

## 二叉搜索树的众数

这题**特殊设定**，可以相同。

### 一般二叉树

直接用map，遍历一次二叉树，然后map输出频率最多的几个二叉树。

### 二叉搜索树

可以转化成一个数组来做。

代码随想录这里提供了一个思路，我觉得很不错，只用一次中序遍历。

和前面最小绝对差类似，直接通过中序遍历，用pre记录上一个中序遍历到的节点，如果cur值相同，则这个频率+1，不同则置1。

然后如果这个频率和最大频率是相同的，则向结果数组中添加这个数字，小于就不加。大于的话就把结果数组清空（因为之前的结果数组里的数频率都小于这个最大频率，因为中序遍历是有序的）

然后输出这个结果数组就行。

### 参考代码

```C++
int cnt = 0;
int maxCnt = 0;
vector<int> result;
TreeNode* pre = nullptr;
void traversal(TreeNode* cur)
{
    if(cur == nullptr)
        return;
    //左
    traversal(cur->left);
    //中
    if(pre == nullptr)
    {
        cnt = 1;
    }
    else if(pre->val == cur->val)
    {
        cnt++;
    }
    else
    {
        cnt = 1;
    }
    pre = cur;

    if(cnt == maxCnt)
    {
        result.push_back(cur->val);
    }

    if(cnt > maxCnt)
    {
        result.clear();
        maxCnt = cnt;
        result.push_back(cur->val);
    }

	//右
    traversal(cur->right);
}
vector<int> findMode(TreeNode* root) {
    traversal(root);
    return result;
}
```

## 二叉搜索树的插入删除

### 插入

插入如果不考虑树的平衡的话，其实很简单：

```C++
TreeNode* insertIntoBST(TreeNode* root, int val) {
    if(root == nullptr)
    {
        TreeNode* node = new TreeNode(val);
        return node;
    }
    if(root->val < val)
        root->right = insertIntoBST(root->right, val);
    else
        root->left = insertIntoBST(root->left, val);

    return root;
}
```

找到空位，然后插入就行了。无需调整树的姿态。

### 删除

删除就不一样了，你删除了这个节点，如果是一个叶子节点，只需要删除自己就行了。但是删除了一个中间节点的话，你就得考虑这个节点的左右子树应该怎么安排了。

这里又有三种情况：

1. 左子树是非空，右子树为空，则将左子树挂到原来这个节点的位置就行了。
2. 右子树是非空，左子树为空，则将右子树挂到原来这个节点的位置就行了。
3. 左右都非空，这个就比较麻烦了，有两种比较简单的解决方法：
   1. 将左子树挂在右子树的最左节点的左节点。
   2. 将右子树挂在左子树的最右节点的右节点。

这样才能保持这颗二叉搜索树的性质。

代码如下：

```C++
TreeNode* deleteNode(TreeNode* root, int key) {
    if(root == nullptr)
        return nullptr;
    if(root->val == key)
    {
        if(root->left == nullptr && root->right == nullptr) //左右节点都为空
            return nullptr;
        else if(root->left == nullptr) // 左空
            return root->right;
        else if(root->right == nullptr) // 右空
            return root->left;
        else //左右都不为空,将左子树连接到右子树的最左边的节点
        {
            TreeNode* cur = root->right;
            while(cur->left)
            {
                cur = cur->left;
            }
            cur->left = root->left;
            return root->right;
        }
    }

    if(root->val > key)
        root->left = deleteNode(root->left, key);
    else
        root->right = deleteNode(root->right, key);
    return root;
}
```



# 最近公共祖先

## 普通二叉树

普通二叉树的最近公共祖先的思路就是从底至上地遍历二叉树。因为我们只有知道这两个目标节点的位置，然后向父节点倒退才能知道这个最近的公共祖先是谁。

对于前序来说，其遍历方式是自顶向下遍历，而后序正是一个自底向上的遍历（因为先处理左右子树，再处理本节点的逻辑）。

所以我们的遍历方式是后序遍历：

代码如下，注释辅助理解：

```C++
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    if(root == nullptr || root == p || root == q) //如果是空节点、q或p，直接返回root，可以直接知道是否找到了pq
    {
        return root;
	}
    //后序遍历
    TreeNode* leftResult = lowestCommonAncestor(root->left, p, q);
    TreeNode* rightResult = lowestCommonAncestor(root->right, p, q);
    //处理中间节点，我用几个if来写，更容易理解。
    if(leftResult == nullptr && rightResult == nullptr)		//说明这个节点的左右子树都没有p、q
        return nullptr;
    if(rightResult && leftResult)	//如果左右节点都不是nullptr的话，说明p和q分别在root的左右子树，那么root就是那个最近公共节点。
        return root;
    if(leftResult)		//说明p，q至少有一个在左节点。如果一个在，返回的就是q或者p。如果两个都在，说明leftResult就是最近公共祖先
        return leftResult;
    if(rightResult)		//同leftResult
        return rightResult;
    return root;
}
```

然后最后的这个地方可以处理地更简单点：

```C++
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    if(root == nullptr || root == p || root == q) //如果是空节点、q或p，直接返回root，可以直接知道是否找到了pq
    {
        return root;
	}
    //后序遍历
    TreeNode* leftResult = lowestCommonAncestor(root->left, p, q);
    TreeNode* rightResult = lowestCommonAncestor(root->right, p, q);
    if(leftResult && rightResult)
        return root;
    return leftResult? leftResult : rightResult;
}
```

因为左右结果有一个空指针和全是空指针其实是可以合并在一个return里面完成。

## 二叉搜索树

因为二叉搜索树的性质，中间节点的值大于左子树的所有节点，小于右子树的所有节点。所以，如果自顶向下遍历，第一次发现某个节点值在pq之间的，说明这个节点一定是p和q的最近公共祖先。

公共祖先应该没问题，为什么这个第一个一定是最近呢？

借用一下代码随想录的图：

![235.二叉搜索树的最近公共祖先](https://file1.kamacoder.com/i/algo/20220926164214.png)

我们可以看到，5节点是我们第一个找到的满足节点值在p(9)q(1)之间的节点。

此时向左走的范围是[1,5]，不包含9，说明3不是9的祖先，向右走的范围是[5,9]，说明8不是1的祖先。

代码就可以这么写：

```C++
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    if(root == nullptr)
        return nullptr;
    if(root->val > max(p->val, q->val))
    {
        return lowestCommonAncestor(root->left, p, q);
    } 
    else if(root->val < min(p->val, q->val))
    {
        return lowestCommonAncestor(root->right, p, q);
    }
    else
    {
        return root;
    }
}
```

