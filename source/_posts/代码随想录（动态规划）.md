---
title: 代码随想录（动态规划）
date: 2025-05-26 14:06:38
tags: [刷题, 动态规划, 背包问题]
categories: 代码随想录
description: 动态规划，只能说慢慢来吧。
---

# 动态规划

动态规划，想起来好多次都失败在了这里，之前根据灵茶山艾府大佬的题单练过一段时间，感觉这个还是比较套路化的。

我认为的动态规划就是如果一个问题可以由子问题的答案得到，那么那些子问题也可以由同样的子子问题的答案得到。那么最终，这些就能由一些原子问题的答案获得最终子问题的答案。同时为了避免对子问题的重复求解，采用将子问题的结果记录下来，以空间换时间。

其中最难的部分是如何进行子问题的拆分，这个我一般的做法就是两种，一个是想最终状态应该是由哪些状态转化过来，另一个就是当前状态能转化到哪几个状态。

其实就是两种思维方式，一个是归，一个是推。

但核心都是找到一个状态转移公式，也就是所说的递推公式。

## 五步走

代码随想录中讲了一个五步走，我认为这个思路还是很不错的。

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

尤其是第一步，一定要弄清楚dp数组所记录的是什么？他们的下标所表示的是什么？一般来说，dp数组的含义就是如果n=下标时的答案。

第二步，我的习惯做法是前面所说的，可以从0或者1这些初始状态开始向后推，也可以从最后n的地方去思考需要解决哪些子问题。

## 输出DP数组

首先可以先找一个例子，自己根据确定的递推公式和DP数组，先推一遍结果。

然后再用写完的代码，将最终的or中间的整个DP数组状态打印出来，看一看哪里和自己推出来不同。

如果是不一样，那么就是代码存在问题。

如果是一样的，那完了，思路有问题了。（bushi）其实也没完，就得要想是不是哪里对题目理解错了，自己的递推公式是不是有问题，自己的DP数组是不是设置错了等。

# 整数拆分

# 不同的二叉搜索树

这题是第一道在代码随想录中我卡住的动规题目，主要确实有点没想到是如何拆解子问题的。

这里我应该理解了。

## 子问题分解的理解

其实这些数字反而影响了思考，我们不妨拿掉这些数字，就把它当作一个二叉树，只不过不是随便的一颗二叉树。

这里我的想法是一个n节点的二叉搜索树，我们就拿出一个节点作为根节点。那么左子树和右子树的节点数和应该是n-1。如果说左子树的节点数是$i$，则右子树的节点树就是$n-1-i$对吧。然后左子树和右子树都应该满足二叉搜索树，则说明左子树的是一个子问题：$i$个节点的二叉搜索树有多少种。右子树的子问题是$n-1-i$个节点的二叉搜索树有多少种？左子树的节点数是$i$，右子树的节点树是$n-1-i$这种情况的二叉搜索树的形态有左子树的可能数乘以右子树的可能数。

然后从$i=0$枚举到$i=n-1$

以上，我们就把这个题进行了一个子问题的分解，同时也差不多可以得出这个题的递推公式。

## 五步走

1. 下标表示二叉搜索树有$i$个节点，DP数组的含义是$i$个节点的二叉搜索树有多少种。
2. 递推公式：$dp[i] = \sum_{j=1}^{j=i-1}dp[j]*dp[i-j-1]$
3. dp数组的初始化：$dp[0]=1$，这个是没法遍历到的
4. 我习惯的一个顺序是从前往后。
5. 这个可以稍微推一下，但我就不推了，🤭。

## 代码

```C++
int numTrees(int n) {
    vector<int> dp(n+1);
    dp[0] = 1;
    for(int i=1; i<=n; i++)
    {
        for(int j=0; j<i; j++)
        {
            dp[i] += dp[j] * dp[i-j-1];
        }
    }
    return dp[n];
}
```

