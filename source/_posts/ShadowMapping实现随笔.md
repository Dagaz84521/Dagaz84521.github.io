---
title: ShadowMapping实现随笔
date: 2025-05-27 18:55:39
tags: [OpenGL, ShadowMapping]
categories: 
- [计算机图形学, 图形学实践]
description: 根据LearnOpenGL还有浅墨翻译的RTR4实现的ShadowMapping
---

# 一、ShadowMapping

> 1978年，Williams [1888]提出了一种通用的、基于z-buffer的渲染器，它可以在任意物体上快速生成阴影。其核心想法是从光源的位置出发，使用z-buffer来渲染整个场景，然后再生成阴影效果。能够被光源“看见”的任何物体都会被照亮，光源“看不见”的物体则都处于阴影中。实际上在图像渲染的时候，我们最终只需要这个z-buffer即可，即我们只需要场景的深度信息；因此在这个特殊的场景渲染中，我们可以关闭光照、纹理等选项，也不用向颜色缓冲写入任何值。
>
> 在从光源视角渲染整个场景之后，z-buffer中的每个像素现在代表了最靠近光源的物体深度值。我们将这个z-buffer中的内容叫做阴影贴图（shadow map），有时候也会称为阴影深度图（shadow depth map）或者阴影缓冲区（shadow buffer）等。为了使用这个阴影贴图来生成阴影效果，我们会从相机的位置来对场景进行第二次渲染。在渲染每个图元的时候，对于该图元所覆盖的每个像素位置，我们都会将其与阴影贴图进行深度比较：如果着色点比阴影贴图中对应位置到光源的距离更远，则说明该点位于阴影中，否则该点不在阴影中。该算法是利用纹理映射实现的，如图7.10所示。阴影映射是一种十分流行的算法，因为它的计算成本相对来说是可预测的。创建阴影贴图的开销，与需要渲染的图元数量大致呈线性关系，并且访问时间是常量。在光源和物体不发生移动的场景中（例如一些计算机辅助设计应用CAD中），我们可以只生成一次阴影贴图，并在每一帧中进行重复使用。

其实思路很容易懂。

我们先思考为什么会产生阴影？

因为光线没办法到达这里，对吧。更准确点说，在到达这个点A之前，先被某个点B拦住了。也就是说这条光路上，点B离光源L更近。

OK，再来想，我们为什么看不到被挡住的事物A？因为从物体上回来的光线被另一个事物B挡住了。在这条光路上，事物B离我的眼睛更近。

OK，假如我们在光源向光线方向看，能看到点B，但看不到点A。

所以，一个场景中的某个点，是否被阴影覆盖，就要看在光源能不能看到这个点。那么如何判断一个点能不能被光源看见，就是看在这个点到光源的这条光路上，是否存在一个离光源更近的点。

也就是这个图所表达的意思：

![img](https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_theory_spaces.png)

眼睛观察到的点P并不能在光源处被“光源”所看见，所以点P处在阴影之中。

也就是说在CP这条光路上，点C离光源比点P离光源更近。换一个更符合图形学的说法就是，对于光源观察空间来说，点P的深度比点C要大。

我们可以通过把光源所能看见的点都记录下来，然后比较这个点的深度，就可以知道这个点能不能被光源看见。而记录光源所能看见的点，就是一个从光源观察空间的深度贴图，也就是阴影贴图(Shadow Map)。

对于一个定向光，只需要一张正交投影的贴图就行了。而对于一个点光源，则需要用到立方体贴图。

接下来的

# 二、定向光阴影贴图

如何获得这个阴影贴图呢？就是将摄像头放在光源位置，进行一次场景渲染，只不过这个场景我们不需要其颜色信息，只需要知道其深度信息。

## 光源观察空间的MVP矩阵

我们先做定向光（比如阳光）。由于定向光，所有的光线都是**平行**的。所以不会出现透视的情况，用正交投影就行。

所以投影矩阵就是：`glm::mat4 lightProjection = glm::ortho(-10.0f, 10.0f, -10.0f, 10.0f, near_plane, far_plane);`

观察矩阵就是光源位置放置一个摄像机，其观察方向是光线方向。当然，这里我是直接使用了glm库的lookAt函数：`glm::mat4 lightView = glm::lookAt(lightPos, glm::vec3(0.0f), glm::vec3(0.0, 1.0, 0.0));`

这里可以稍微再复习一下这个函数需要三个vec3类型的向量：**摄像机的位置**， **摄像机看的位置**和**世界空间的上方向**。

模型矩阵就是正常的场景绘制就行了。

## 帧缓冲的设置

> 用于写入颜色值的颜色缓冲、用于写入深度信息的深度缓冲和允许我们根据一些条件丢弃特定片段的模板缓冲，这些缓冲结合起来叫做帧缓冲(Framebuffer)，它被储存在GPU内存中的某处。OpenGL允许我们定义我们自己的帧缓冲，也就是说我们能够定义我们自己的颜色缓冲，甚至是深度缓冲和模板缓冲。

这里再复习一下帧缓冲是怎么使用的。

首先，我们绘制在屏幕上的内容实际上用的是默认帧缓冲，一共有两块。当一块绘制完了通过`glfwSwapBuffers(window);`
