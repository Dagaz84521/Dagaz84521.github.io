---
title: 代码随想录（贪心算法）
date: 2025-05-21 10:27:28
tags: [刷题，贪心算法]
categories: 代码随想录
description: 不太会贪心算法，主要是记录一些我感觉理解的不是很透彻的题目，方便以后回顾
---

# 摆动序列

## 2025/05/21	第一次

首先，注意序列和子串的区别。

**序列不一定在原数组中是连续的，只要顺序是对的就行**。

比如1，2，3，4，5，6，7中1，3，5，7就是一个子序列。

**而子串则需要在原数组中是相连的**

比如1，2，3是一个子串，而1，3，5，7就不是一个子串。

总而言之，子序列应该包含子串。

然后我最开始的一个做法是：

```C++
int wiggleMaxLength(vector<int>& nums) {
    int m = 1;
    if(nums.size() <= 1)
        return nums.size();
    vector<int> n(nums.size()-1);
    for(int i=1; i<nums.size(); i++)
    {
        if(nums[i] > nums[i-1])
            n[i-1] = 1;
        else if(nums[i] < nums[i-1])
            n[i-1] = -1;
        else 
            n[i-1] = 0;
    }
    int pre = 0;
    for(int i=1; i<n.size(); i++)
    {
        if(n[pre] == - n[i] && n[pre] != 0)
        {
            m++;
            pre = i;
        }
    }
    return m+1;
}
```

先将数组中所有的先求一次差，然后再根据这个差，去寻找和pre相反性质的数，并持续维持pre。

但这个方法在遇到开始是多个相同的数，貌似会出很多问题，暂时也不知道该怎么改。

所以直接看代码随想录的题解了。

其思路是，**删除单调的坡中间的数，只保留首尾**。

也就是只有`prediff < 0 && curdiff > 0`或者`prediff > 0 && curdiff < 0`的时候需要统计。

但这个不是最难的，最难的应该是平坡和整个数组的首尾处理。

但既然如此，我们先写一个基本思路框架吧：

```C++
int wiggleMaxLength(vector<int>& nums) {
    if(nums.size() <= 1)
        return nums.size();
   	int prediff;
    int curdiff;
    int result;
    for(int i=0; i<nums.size(); i++)
    {
        curdiff = nums[i+1] - nums[i];
        if((preDiff < 0 && curDiff > 0) || (preDiff > 0 && curDiff < 0))
        {
            result++;
        }
        prediff = curdiff;
    }
    return result;
}
```

然后就需要考虑各个特殊情况了。

### 上下坡中有平坡

![img](https://file1.kamacoder.com/i/algo/20230106170449.png)

如果按我们现在的代码来运行这个结果的话（暂且不论几个初始值），我们就看上的2（或者下坡的2）， 其preDiff是1，curDiff是0（下坡2同理）.是不会被计算在里面的，但是[1,2,1]是成立的，所以需要将preDiff或者curDiff的判断条件修改成容纳=0。但只能修改一个，因为我们只需要1个，如果两端都容纳0，就会导致两端都能接受。

所以可以先把代码修改成：

```C++
int wiggleMaxLength(vector<int>& nums) {
    if(nums.size() <= 1)
        return nums.size();
   	int prediff;
    int curdiff;
    int result;
    for(int i=0; i<nums.size()-1; i++)
    {
        curdiff = nums[i+1] - nums[i];
        if((preDiff <= 0 && curDiff > 0) || (preDiff => 0 && curDiff < 0))
        {
            result++;
        }
        prediff = curdiff;
    }
    return result;
}
```

这样就只能容纳最右端的那个数了。

### prediff和result的初始值

因为curdiff是通过每个数和其后一个数来计算出来的，所以无需考虑其初始值。

我认为，考虑这两个的初始值，其实就是在考虑，我们的解法如何处理首尾的情况。

我们知道在情况一中，prediff=0，curdiff>0或<0意味着什么？没错，一个平坡的右端是吧。如果curdiff=0，说明其是一个平坡的左端，或者中间。

OK，那么对于**首节点**来说，curdiff>0或<0说明其是一个上下坡的起点，是需要加入我们的序列的。如果curdiff=0，说明是一个平坡的左端，我们不需要这个点。

这正好和情况1分析的内容是对上的。所以可以直接将prediff的值设置成0，将其和上下坡的左端点的处理逻辑相同。

也可以理解是首节点的左边有一个假设节点，其值和首节点相同，首节点就是一个平坡上的节点了。

接着再来分析result，这需要看最后的节点。看了代码的循环条件后，就会发现最后这个节点是没有curdiff的。这怎么办？其实很简单，直接将这个节点当作子序列就行了。因为无论前面的prediff是怎么样的，我们都可以选择最后这个节点进入子序列，因为最后这个节点一定属于一个坡的端点：

- 上下坡，这都最后一个数了，你不是端点谁是端点
- 平坡，平坡的右端点，参考情况1.

所以无需判断这个节点，将result的初始值设置成1.

```C++
int wiggleMaxLength(vector<int>& nums) {
    if(nums.size() <= 1)
        return nums.size();
   	int prediff=0;
    int curdiff;
    int result=1;
    for(int i=0; i<nums.size()-1; i++)
    {
        curdiff = nums[i+1] - nums[i];
        if((preDiff <= 0 && curDiff > 0) || (preDiff => 0 && curDiff < 0))
        {
            result++;
        }
        prediff = curdiff;
    }
    return result;
}
```

### 单调坡度有平坡

这是情况1我们的处理方法导致的一个问题：
![img](https://file1.kamacoder.com/i/algo/20230108171505.png)

在这种情况，中间平坡的右端点，其实是不应该算在最终结果的。但最后我们算在里面了。

这是因为我们在处理平坡的时候，并未将平坡的上面的数删去，而只是判断了一次。

可以采用一种方法，就是让平坡中的2继承最左端的性质。

也就是在1节点判断完后，将prediff传给平坡：

```C++
int wiggleMaxLength(vector<int>& nums) {
    if (nums.size() <= 1)
        return nums.size();
    int prediff = 0;
    int curdiff;
    int result = 1;
    for (int i = 0; i < nums.size() - 1; i++) {
        curdiff = nums[i + 1] - nums[i];
        if ((prediff <= 0 && curdiff > 0) ||
            (prediff >= 0 && curdiff < 0)) {
            result++;
            prediff = curdiff;
        }
    }
    return result;
}
```

也就是只有在向子序列增加的时候修改prediff。

### 思考

思考完代码随想录的题解后，其实我之前的做法还是有一定的相似之处的。

比如上下坡中中间和端点没区别，所以可以只取端点。

我将我的m设置成1，其实是我想的是首节点肯定是在子序列中的。但是我的想法没有一个主轴，导致很混乱。而代码随想录的一个主轴就是，以右为尊。右边就是比左边高贵（尾节点一定在子序列中，平坡中选择最右端的节点）

# 最大子序和

这题是我自己想出来的，嘻嘻。

其实想法还是比较简单的，如果前面的数所能得到的子数组和最大，加上当前的数，如果比当前的数小，那么就可以丢弃前面的，只用当前的这个数。

举个例子，如果前面的所有数能获得子数组和最大为-10，这个数是10，那么就可以丢弃前面的最大子数组和，而到这数的最大和子数组就是这个数，子数组的最大和也就是10。

```C++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        for(int i=1; i<nums.size(); i++)
        {
            nums[i] = max(nums[i], nums[i-1]+nums[i]);
        }
        int result = nums[0];
        for(int i=1; i<nums.size(); i++)
        {
            result = max(result, nums[i]);
        }
        return result;
    }
};
```

# 根据身高重建队列

**一般这种数对，还涉及排序的，根据第一个元素正向排序，根据第二个元素反向排序，或者根据第一个元素反向排序，根据第二个元素正向排序，往往能够简化解题过程。**

这题数对一个是身高，一个是前面有多少>=自身身高的人。

这题我们选择对身高进行逆向排序，然后对前面有多少人进行正向排序。

为什么会这么选择呢？

我就浅谈一下我的粗浅理解，首先为什么高的要排在前面，因为高的人先确定了顺序，其他身高低的人无论处在什么位置也不会影响身高高的人的相对顺序（也就是people[1]的值）。

那又为什么需要对有多少人进行正向排序呢？因为对于同身高的人，我们先插入那些people[1]更小的人时，我们能保持整个队伍是符合题意的。如何理解这个，就比如说我们只有3个高度为7，people\[i][1]分别为0,1,2的人。如果我们先插入people\[2](7,2)这个人的话，这个队伍是不符合题意的。

通过这样的一个顺序，我们就能保证，在我们每一步结束后，整个队伍都是符合题意的。

然后就是如何对这个排序后的数组进行改序的问题了：

我们假设有一个已经调好序的队伍了，还有一个我们即将插入的一个人。

在这个队伍中，所有人的身高都是>=待插入的人的。那么这个人的people\[i][1]就表示这个人在队伍中的位置：

代码如下：

```C++
static bool cmp(vector<int> a, vector<int> b)
{
    if(a[0] > b[0])
        return true;
    else if(a[0] == b[0] && a[1] < b[1])
        return true;
    return false;
}
vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
    vector<vector<int>> res;
    sort(people.begin(), people.end(), cmp);
    for(auto p: people)
    {
        if(p[1] >= res.size())
            res.push_back(p);
        else
            res.insert(res.begin()+p[1], p);
    }
    return res;
}
```

这是leetcode上[【先排序，再插队】动画演示算法过程，有点小套路](https://leetcode.cn/problems/queue-reconstruction-by-height/solutions/486493/xian-pai-xu-zai-cha-dui-dong-hua-yan-shi-suan-fa-g/)

的思路改写的C++代码。

但我认为还是有点可以修改的地方，就是for循环中的if其实没有必要：

```C++
vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
    vector<vector<int>> res;
    sort(people.begin(), people.end(), cmp);
    for(auto p: people)
        res.insert(res.begin()+p[1], p);
    return res;
}
```

直接insert就行了。

当然，这里如果使用vector的话，插入操作会导致效率的降低。

因为vector实际上是一个动态数组，其大小的话是会随着数组的增加而进行扩容的。一般一次扩容就是翻倍的大小，而翻倍又会导致需要重新分配内存。

此外insert操作的时候会将后续的元素向后移，所以又需要后移的开销。

所以对于插入操作频繁的，可以选择改用list。



