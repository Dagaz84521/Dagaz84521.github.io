---
title: 代码随想录（图论）
date: 2025-06-04 11:19:45
tags: [刷题, 图论, 深搜, 广搜, 并查集]
categories: 代码随想录
description: 终于到了以前没怎么练过的图论了，感觉图论两个难点：一、把题目的输入转化为图。二、把题看懂，转化为可用的知识。
---

# 深度优先搜索

施工优先度：低

# 广度优先搜索

施工优先度：低

# 岛屿问题

施工优先度：中

# 并查集

因为以前没学过，所以先来试一试。

并查集，其实分开来说就是在集合上进行查询合并的操作。

这里借用UP主[蓝不过海呀](https://space.bilibili.com/401399175)的图来方便描述：（[并查集 - 基本操作, 路径压缩, 按秩合并](https://www.bilibili.com/video/BV1zZRSYUEWV/)）

![image-20250604112938842](https://cdn.jsdelivr.net/gh/Dagaz84521/DagazBlogPicture@main/img/20250604112945945.png)

这里有三个集合，并查集实际上就是将这几个集合进行查询和合并操作。

比如查询就是：我想知道4号元素在哪个集合。合并就是将4号元素所在集合和7号元素所在集合合并。

那么我们就得要把这个集合中的元素都组织起来，用图论的视角来看，一个非常好的方式就是通过一条边将两个同一集合中的元素连接起来。

但是仅仅将同一几何中的元素通过边连接起来，整个集合就看起来没有什么秩序，这个集合也没有一个标志。

所以一个很好的解决方法就是使用其中的某个节点当这个集合的leader，也就是根节点，其他节点都指向这个节点。

![image-20250604113856513](https://cdn.jsdelivr.net/gh/Dagaz84521/DagazBlogPicture@main/img/20250604113856563.png)

这样这些节点就构成了一个森林。

![image-20250604113948014](https://cdn.jsdelivr.net/gh/Dagaz84521/DagazBlogPicture@main/img/20250604113948076.png)

当我们需要知道4号节点属于哪个集合的时候，我们只需要找到4号的父节点就能知道4号属于哪个集合了。

这就还有一个问题了，如果是1,3,5怎么办呢？

诶，这个其实很好解决，只需要让1,3,5指向自己就行了。

![image-20250604114148758](https://cdn.jsdelivr.net/gh/Dagaz84521/DagazBlogPicture@main/img/20250604114148827.png)

这样，我们只需要一个一维数组就能表示这个图了。

![image-20250604114305353](https://cdn.jsdelivr.net/gh/Dagaz84521/DagazBlogPicture@main/img/20250604114305390.png)

非常的舒服。

## 查询

查询的代码就比较简单了，我采用的是递归，这是有很多好处的。

```C++
int find(int x)
{
    if(p[x] == x) //递归结束条件：找到树的根节点
        return x;
    else 
        return find(p[x]);
}
```

## 合并

合并则是将两个根节点中的一个变成另一个根节点的子节点就行了。

```C++
void Union(int x, int y)
{
    int rootx = find(x);
    int rooty = find(y);
    if(rootx != rooty)
        p[rootx] = rooty;
}
```

## 路径压缩

但是，我们会发现，我们的树在合并后，高度会增加：

![image-20250604115007440](https://cdn.jsdelivr.net/gh/Dagaz84521/DagazBlogPicture@main/img/20250604115007477.png)

比如这张图，{1,4,8}和{3,5,2,7}合并后，1号集合的子节点不会指向3，而是继续指向1。

那么我们后面再次查找4的时候，虽然确实能正确的返回3，却还是比4直接指向3需要多一步查看1的父节点。

那我为什么不能直接把4挂在3号节点下呢？

这就是在查找的过程中进行路径压缩所作的事了，代码很简单:

```C++
int find(int x)
{
    if(p[x] == x) //递归结束条件：找到树的根节点
        return x;
    else 
        return x = find(p[x]);
}
```

这样，只要查找过一次4，4号就会直接被挂在3号节点下，而且也会把4号到3号直接路径上的所有节点都挂在3号下。以后就可以直接完成了。

## 带秩合并

还有一个问题，就是我们会发现，我们合并的方式不同，会导致产生两颗高度不同的树，而高度过高，显然会降低查找的效率。所以，就需要想办法尽可能地减少树的高度。

一种很直觉的做法就是，将矮的树，挂在高的树下面，这样能保证新树的高度必然小于原本的树。这就是按高度合并。

```C++
void Union(int x, int y)
{
    int rootx = find(x);
    int rooty = find(y);
    if(rootx != rooty){
        if(h[rootx]<h[rooty]){
        	p[rootx]=rooty
        }else if(h[rootx]>h[rooty]){
        	p[rooty]=rootx;
        }else{
        	p[rootx]=rooty;
        	h[rooty]++;
        }
	}
}
```

但这种做法在使用路径压缩的时候会出现问题，因为路径压缩有可能会改变树的高度，而如果重新计算树高，则又会增加计算量。而如果不管路径压缩带来的变化，这种方式也还能将树的高度控制在logn以内，所以没必要去重新计算树高了。

还有一种做法就是按大小合并。这种方式就是合并树，将节点数少的数合并进节点数多的树。虽然确实有可能会出现节点数少但是数很高的情况，但也能优化一部分。

```C++
void Union(int x, int y)
{
    int rootx = find(x);
    int rooty = find(y);
    if(rootx != rooty){
        if(s[rootx]<=s[rooty]){
            p[rootx]=rooty;
            s[rooty]+=s[rootx];
        }else{
            p[rooty]=rootx;
            s[rootx]+=s[rooty];
        }
    }
        
}
```

差不多就这些内容了，哦对了，带秩合并的两个数组其实可以合并到同一个数组里，根节点用负数来记录自己的高度or大小就行了。

然后题目的话就明天开始写吧。
