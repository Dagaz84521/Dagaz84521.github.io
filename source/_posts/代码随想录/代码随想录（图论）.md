---
title: 代码随想录（图论）
date: 2025-06-04 11:19:45
tags: [刷题, 图论, 深搜, 广搜, 并查集]
categories: 代码随想录
description: 终于到了以前没怎么练过的图论了，感觉图论两个难点：一、把题目的输入转化为图。二、把题看懂，转化为可用的知识。
---

# 深度优先搜索

施工优先度：低

# 广度优先搜索

施工优先度：低

# 岛屿问题

施工优先度：中

# 并查集

因为以前没学过，所以先来试一试。

并查集，其实分开来说就是在集合上进行查询合并的操作。

这里借用UP主[蓝不过海呀](https://space.bilibili.com/401399175)的图来方便描述：（[并查集 - 基本操作, 路径压缩, 按秩合并](https://www.bilibili.com/video/BV1zZRSYUEWV/)）

![image-20250604112938842](https://cdn.jsdelivr.net/gh/Dagaz84521/DagazBlogPicture@main/img/20250604112945945.png)

这里有三个集合，并查集实际上就是将这几个集合进行查询和合并操作。

比如查询就是：我想知道4号元素在哪个集合。合并就是将4号元素所在集合和7号元素所在集合合并。

那么我们就得要把这个集合中的元素都组织起来，用图论的视角来看，一个非常好的方式就是通过一条边将两个同一集合中的元素连接起来。

但是仅仅将同一几何中的元素通过边连接起来，整个集合就看起来没有什么秩序，这个集合也没有一个标志。

所以一个很好的解决方法就是使用其中的某个节点当这个集合的leader，也就是根节点，其他节点都指向这个节点。

![image-20250604113856513](https://cdn.jsdelivr.net/gh/Dagaz84521/DagazBlogPicture@main/img/20250604113856563.png)

这样这些节点就构成了一个森林。

![image-20250604113948014](https://cdn.jsdelivr.net/gh/Dagaz84521/DagazBlogPicture@main/img/20250604113948076.png)

当我们需要知道4号节点属于哪个集合的时候，我们只需要找到4号的父节点就能知道4号属于哪个集合了。

这就还有一个问题了，如果是1,3,5怎么办呢？

诶，这个其实很好解决，只需要让1,3,5指向自己就行了。

![image-20250604114148758](https://cdn.jsdelivr.net/gh/Dagaz84521/DagazBlogPicture@main/img/20250604114148827.png)

这样，我们只需要一个一维数组就能表示这个图了。

![image-20250604114305353](https://cdn.jsdelivr.net/gh/Dagaz84521/DagazBlogPicture@main/img/20250604114305390.png)

非常的舒服。

## 查询

查询的代码就比较简单了，我采用的是递归，这是有很多好处的。

```C++
int find(int x)
{
    if(p[x] == x) //递归结束条件：找到树的根节点
        return x;
    else 
        return find(p[x]);
}
```

## 合并

合并则是将两个根节点中的一个变成另一个根节点的子节点就行了。

```C++
void Union(int x, int y)
{
    int rootx = find(x);
    int rooty = find(y);
    if(rootx != rooty)
        p[rootx] = rooty;
}
```

## 路径压缩

但是，我们会发现，我们的树在合并后，高度会增加：

![image-20250604115007440](https://cdn.jsdelivr.net/gh/Dagaz84521/DagazBlogPicture@main/img/20250604115007477.png)

比如这张图，{1,4,8}和{3,5,2,7}合并后，1号集合的子节点不会指向3，而是继续指向1。

那么我们后面再次查找4的时候，虽然确实能正确的返回3，却还是比4直接指向3需要多一步查看1的父节点。

那我为什么不能直接把4挂在3号节点下呢？

这就是在查找的过程中进行路径压缩所作的事了，代码很简单:

```C++
int find(int x)
{
    if(p[x] == x) //递归结束条件：找到树的根节点
        return x;
    else 
        return x = find(p[x]);
}
```

这样，只要查找过一次4，4号就会直接被挂在3号节点下，而且也会把4号到3号直接路径上的所有节点都挂在3号下。以后就可以直接完成了。

## 带秩合并

还有一个问题，就是我们会发现，我们合并的方式不同，会导致产生两颗高度不同的树，而高度过高，显然会降低查找的效率。所以，就需要想办法尽可能地减少树的高度。

一种很直觉的做法就是，将矮的树，挂在高的树下面，这样能保证新树的高度必然小于原本的树。这就是按高度合并。

```C++
void Union(int x, int y)
{
    int rootx = find(x);
    int rooty = find(y);
    if(rootx != rooty){
        if(h[rootx]<h[rooty]){
        	p[rootx]=rooty
        }else if(h[rootx]>h[rooty]){
        	p[rooty]=rootx;
        }else{
        	p[rootx]=rooty;
        	h[rooty]++;
        }
	}
}
```

但这种做法在使用路径压缩的时候会出现问题，因为路径压缩有可能会改变树的高度，而如果重新计算树高，则又会增加计算量。而如果不管路径压缩带来的变化，这种方式也还能将树的高度控制在logn以内，所以没必要去重新计算树高了。

还有一种做法就是按大小合并。这种方式就是合并树，将节点数少的数合并进节点数多的树。虽然确实有可能会出现节点数少但是数很高的情况，但也能优化一部分。

```C++
void Union(int x, int y)
{
    int rootx = find(x);
    int rooty = find(y);
    if(rootx != rooty){
        if(s[rootx]<=s[rooty]){
            p[rootx]=rooty;
            s[rooty]+=s[rootx];
        }else{
            p[rooty]=rootx;
            s[rootx]+=s[rooty];
        }
    }
        
}
```

差不多就这些内容了，哦对了，带秩合并的两个数组其实可以合并到同一个数组里，根节点用负数来记录自己的高度or大小就行了。

然后题目的话就明天开始写吧。

# 最小生成树

呵呵，昨天没写，但是昨天Leetcode的每日一题就是并查集。今天(2025/6/6)是一个贪心+栈。

最小生成树有两种主要的算法，一个是prim算法，一个是kruskal算法，这两个算法其实在算法导论这门课中就学过了。但是其实快忘差不多了，只记得一个是边，一个是点。

然后又回看了当时看的：[图-最小生成树-Prim(普里姆)算法和Kruskal(克鲁斯卡尔)算法](https://www.bilibili.com/video/BV1wG411z79G/?spm_id_from=333.337.search-card.all.click)，稍微回想起来一点。

那就一个一个来吧：

## Prim算法

Prim算法的思想可以分成三部：

1. 找到离当前生成树最近的点
2. 把这个点加入生成树
3. 更新非生成树节点到生成树的距离

具体的代码可以参照以下模板：

```C++
#include<iostream>
#include<vector>
#include <climits>

using namespace std;
int main() {
    int v, e;
    int x, y, k;
    cin >> v >> e;
    vector<vector<int>> grid(v + 1, vector<int>(v + 1, 10001));
    //使用邻接矩阵记录无向图，两个都需要标记值
    while (e--) {
        cin >> x >> y >> k;
        grid[x][y] = k;
        grid[y][x] = k;
    }
    vector<int> minDist(v + 1, 10001); // 对应下标的点到当前生成树的最小距离
    vector<bool> isInTree(v + 1, false); // 对应下标的点是否已经在树里
	
    for (int i = 1; i < v; i++) {
        int cur = -1; 
        int minVal = INT_MAX;
        for (int j = 1; j <= v; j++) { 
            if (!isInTree[j] &&  minDist[j] < minVal) {
                minVal = minDist[j];
                cur = j;
            }
        }
        isInTree[cur] = true;
        for (int j = 1; j <= v; j++) {
            if (!isInTree[j] && grid[cur][j] < minDist[j]) {
                minDist[j] = grid[cur][j];
            }
        }
    }
    
    // 统计结果
    int result = 0;
    for (int i = 2; i <= v; i++) { 
        result += minDist[i];
    }
    cout << result << endl;

}
```

## Kruskal算法

Kruskal算法的一个大致思路是：

1. 边的权值排序，因为要优先选最小的边加入到生成树里
2. 遍历排序后的边
   - 如果边首尾的两个节点在同一个集合，说明如果连上这条边图中会出现环
   - 如果边首尾的两个节点不在同一个集合，加入到最小生成树，并把两个节点加入同一个集合

这里用到了集合的，而且还要判断两个节点在不在一个集合，现在的我们应该很容易就能想到解决方法了——并查集。

我们遍历这些边，然后将两个节点利用并查集组织起来。如果某条边的两个点查询结果相同，则说明这两个点是同一集合，则不是我们要找的边。

但是如果两个点的结果不同，则需要将两个点的集合合并。

```C++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

struct Edge {
    int l, r, val;
};

vector<int> p;

bool cmp(Edge e1, Edge e2)
{
    return e1.val < e2.val;
}

/*并查集*/
void init()
{
    for(int i=0; i<p.size(); i++)
        p[i] = i;
}

int Find(int a)
{
    if(a == p[a])
        return a;
    else
        return p[a] = Find(p[a]);
}

bool Join(int a, int b)
{
    int fa = Find(a);
    int fb = Find(b);
    if(fa == fb)
        return false;
    else
        p[fa] = fb;
    return true;
}
/*并查集*/

/*main函数*/
int main()
{
    int v, e;
    int v1, v2, val;
    vector<Edge> edges;
    int result_val = 0;
    cin >> v >> e;
    p.resize(v+1);
    while (e--) {
        cin >> v1 >> v2 >> val;
        edges.push_back({v1, v2, val});
    }
    sort(edges.begin(), edges.end(), cmp);
    init();
    int result = 0;
    for(auto edge : edges)
    {
        if(Join(edge.l,edge.r))
        {
            result += edge.val;
        }
    }
    cout << result << endl;
    return 0;
}
/*main函数*/
```

# 拓扑排序

拓扑排序一般是做那种工序问题，或者是那种前置条件问题，这种都是有向无环图，就比如说这道题：

> 某个大型软件项目的构建系统拥有 N 个文件，文件编号从 0 到 N - 1，在这些文件中，某些文件依赖于其他文件的内容，这意味着如果文件 A 依赖于文件 B，则必须在处理文件 A 之前处理文件 B （0 <= A, B <= N - 1）。请编写一个算法，用于确定文件处理的顺序。

还有一个作用就是判断有向图是否存在环，这道题的另一部分内容：

> 输出共一行，如果能处理成功，则输出文件顺序，用空格隔开。 
>
> 如果不能成功处理（相互依赖），则输出 -1。

接下来就是拓扑排序思路了：

1. 找到入度为0的节点
2. 删除入度为0的节点，并更新相关节点的入度，并将删除的节点加入答案。

![拓扑排序](https://i-blog.csdnimg.cn/blog_migrate/7f5f2b999933d2d8325f9cb02b8d3439.gif)

然后就是代码：

```C++
#include<iostream>
#include<vector>
#include<unordered_map>
#include<queue>
using namespace std;

int main()
{
    int n,m;
    cin >> n >> m;
    vector<int> degree(n, 0);
    vector<int> result;
    unordered_map<int, vector<int>> mp; //用unordered_map记录有向边
    int s, t;
    while(m--)
    {
        cin >> s >> t;
        mp[s].push_back(t);
        degree[t]++;
    }
	
    queue<int> q; //队列q中的是入度为0的节点。
    for(int i=0; i<n; i++)
    {
        if(degree[i] == 0)
            q.push(i);
    }
    while(!q.empty())
    {
        int i = q.front();
        q.pop();
        result.push_back(i);
        //更新入度
        for(int j : mp[i])
        {
            degree[j]--;
            if(degree[j] == 0)
                q.push(j);
        }
    }
    if(result.size() < n)
        cout << -1 << endl;
    else
    {
        for (int i = 0; i < n - 1; i++) cout << result[i] << " ";
        cout << result[n - 1];
    }
    return 0;
}
```

# Dijkstra算法

最短路是图论中的经典问题即：给出一个有向图，一个起点，一个终点，问起点到终点的最短路径。

接下来要讲Dijkstra和Bellman_ford算法都是求解单源最短路径的问题。

我们先来讲Dijkstra算法。

首先我们就需要先知道这个算法存在一个很严重的局限性：**有向图的权值不能为负数**。要解决有负权边的有向图就需要使用Bellman—ford算法了。

Dijkstra算法的思路和Prim算法其实很相似，不断维护一个到源点的最近距离数组，然后每次选择未访问过的，到源点距离最短的节点，然后更新这个其他节点的最近距离数组。

总结来说，在循环中不断进行这三步：

1. 选源点到哪个节点近且该节点未被访问过
2. 该最近节点被标记访问过
3. 更新非访问节点到源点的距离（即更新minDist数组）

其他的就没有更多需要补充的了，就是代码实现上了：

```C++
int Dijkstra(vector<vector<int>>& grid, int n, int src, int dst) 
{
    vector<int> minDist(n+1, INT_MAX/2);
    vector<bool> visited(n+1, false);
    minDist[src] = 0;
    for(int i=1; i<=n; i++)
    {
        int minVal = INT_MAX;
        int cur = 1;
        for(int j=1; j<=n; j++)
        {
            if(!visited[j] && minDist[j] < minVal)
            {
                cur = j;
                minVal = minDist[j];
            }
        }
        visited[cur] = true;
        for(int j=1; j<=n; j++)
        {
            if(!visited[j] && minDist[cur]+grid[cur][j] < minDist[j])
            {
                minDist[j] = minDist[cur]+grid[cur][j];
            }
        }
#ifdef DEBUG
        for(int i=1; i<n; i++)
        {
            cout << minDist[i] << " ";
        }
        cout << endl;
#endif
    }
    return minDist[dst] == INT_MAX/2? -1 : minDist[dst];
}
```

# Bellman-Ford算法

之前我们提到过，Dijkstra算法无法处理带负权边的单源最短路径问题。

这是因为Dijkstra是无法回头的：

![image-20250608141211633](https://cdn.jsdelivr.net/gh/Dagaz84521/DagazBlogPicture@main/img/image-20250608141211633.png)

确定A后，我们发现其中B的minDist是4，C是3。所以我们将C标记为访问过，然后再更新B。

但是实际上，这个时候，其实经过B再到C的权值是2，要比直接到C短。

而Bellman-Ford算法则是通过**对所有边进行松弛n-1次操作（n为节点数量），从而求得目标最短路**。

那么什么叫松弛呢？松弛其实就是看通过这条边，到达的节点的最短距离是否会变得更小，如果变得更小，那么就使用新的，否则就使用旧的。

以上面这张图的C点为例子吧。假设现在经过若干次数的松弛操作后，C的`minDist`是3（从A过来的），我们开始对BC这条边进行松弛，此时C要么选择是不变也就是`minDist[c]`，或者选择从`minDist[b]=4`的这个节点过来，也就是`minDist[b]+edge[bc]`。此时比较来说，应该是经过BC更短，所以采用这条，更新C点的minDist。

或者说就是`minDist[C] = min(minDist[c], minDist[B]+edge[bc])`

感觉好像和动态规划有点相似。

至于为什么是n-1次松弛呢？首先这个n-1次是最少，也就是说做n次，n+1次，2n次，n的200次方次，都没问题。但也并不是说一定就需要n-1次，有可能一次就完成了，剩下的全是无用循环。这里应该可以进行剪枝操作。

那么为什么是最少呢，个人理解是有一种情况：假设有6个点，从小到大顺序连接，但是边的遍历顺序是后一个逆序的({5,6},{4,5}....)。每次对所有边进行松弛，只有1个节点被更新了，所以要传播到6则需要5次。

此外这个松弛次数k还有一个意义就是从源点经过k条边能到达图中某个点的最短路径。后面会有介绍。

## 基本代码

接下来是代码部分：

```C++
struct Edge{
    int from;
    int to;
    int val;
    Edge(int f, int t, int v):from(f),to(t),val(v){};
}
int BellmanFord(vector<Edge>& edges, int n, int src, int dst)
{
    vector<int> minDist(n+1, INT_MAX/2);
    minDist[src] = 0;
    for(int i=0; i<n; i++)
    {
        for(auto edge:edges)
        {
            int from = edge.from;
            int to = edge.to;
            int val = edge.val;
            if(minDist[from] != INT_MAX/2) //注意不要让未到达过的节点参与，因为有负权边的存在，可能会导致一些问题。
                minDist[to] = min(minDist[to], minDist[from] + val);
        }
    }
    if(minDist[dst] == INT_MAX/2)
        return -1;
    else 
        return minDist[dst];
}
```

## 带负权环判断

但是Bellman-Ford算法无法解决有负权环的图，其实也就根本没法解决，只要能一直在负权环里面绕，就不会有最小值。

但是Bellman-Ford算法能够实现检测图是否存在负权环。之前我们了解到了，n-1次就能保证获得所有点`minDist`。但那是基于无负权环的图。对于有负权环的图，只需要在n-1次遍历后，再进行一次。这次我们不对`minDist`进行修改，而是判断`minDist`是否还在发生变化，如果在变化，则说明存在负环：

```C++
struct Edge{
    int from;
    int to;
    int val;
    Edge(int f, int t, int v):from(f),to(t),val(v){};
}
int BellmanFord(vector<Edge>& edges, int n, int src, int dst)
{
    vector<int> minDist(n+1, INT_MAX/2);
    minDist[src] = 0;
    bool flag = false;
    for(int i=0; i<=n; i++)
    {
        for(auto edge:edges)
        {
            int from = edge.from;
            int to = edge.to;
            int val = edge.val;
            if(i < n){   
            	if(minDist[from] != INT_MAX/2) //注意不要让未到达过的节点参与，因为有负权边的存在，可能会导致一些问题。
                	minDist[to] = min(minDist[to], minDist[from] + val);
            }
            else{
                if(minDist[from] != INT_MAX/2 && minDist[from] + val < minDist[to])
                    flag = true;
            }
        }
    }
    if(flag == true)
        return -2;
    else if(minDist[dst] == INT_MAX/2)
        return -1;
    else 
        return minDist[dst];
}
```

